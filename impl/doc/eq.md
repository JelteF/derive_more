# Using `#[derive(PartialEq)]`

Deriving `PartialEq` works by checking whether two values are equal according to
their type structure.




## Structural equality

Deriving `PartialEq` for enums/structs works in a similar way to the one in `std`,
by comparing all the available fields, but, in the contrast:
1. Does not overconstrain generic parameters.
2. Implements `PartialEq::ne()` method as well, to propagate possible efficient
   implementations of this method from the underlying types.


### Structs

For structs all the available fields are checked for equality.

```rust
# use std::marker::PhantomData;
# use derive_more::PartialEq;
#
trait Trait {
    type Assoc;
}
impl<T: ?Sized> Trait for T {
    type Assoc = u8;
}

#[derive(Debug, PartialEq)]
struct Foo<A, B, C: Trait + ?Sized> {
    a: A,
    b: PhantomData<B>,
    c: C::Assoc,
}

#[derive(Debug)]
struct NoEq;

assert_eq!(Foo::<_, NoEq, NoEq> { a: 3, b: PhantomData, c: 0 }, Foo { a: 3, b: PhantomData, c: 0 });
assert_ne!(Foo::<_, NoEq, NoEq> { a: 3, b: PhantomData, c: 0 }, Foo { a: 0, b: PhantomData, c: 3 });
```
This generates code equivalent to:
```rust
# use std::marker::PhantomData;
#
# trait Trait {
#     type Assoc;
# }
# impl<T: ?Sized> Trait for T {
#     type Assoc = u8;
# }
#
# struct Foo<A, B, C: Trait + ?Sized> {
#     a: A,
#     b: PhantomData<B>,
#     c: C::Assoc,
# }
#
impl<A, B, C: Trait + ?Sized> PartialEq for Foo<A, B, C>
where
    A: PartialEq,
    PhantomData<B>: PartialEq, // `B: PartialEq` is generated by `std` instead
    C::Assoc: PartialEq,       // `C: PartialEq` is generated by `std` instead
{
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self { a: self_0, b: self_1, c: self_2 }, Self { a: other_0, b: other_1, c: other_2 }) => {
                self_0 == other_0 && self_1 == other_1 && self_2 == other_2
            }
        }
    }

    #[inline]
    fn ne(&self, other: &Self) -> bool {
        match (self, other) {
            (Self { a: self_0, b: self_1, c: self_2 }, Self { a: other_0, b: other_1, c: other_2 }) => {
                self_0 != other_0 || self_1 != other_1 || self_2 != other_2
            }
        }
    }
}
```


### Enums

For enums the first check is whether these two values represent the same variant,
and after that we check fields equality.

```rust
# use std::marker::PhantomData;
# use derive_more::PartialEq;
#
# trait Trait {
#     type Assoc;
# }
# impl<T: ?Sized> Trait for T {
#     type Assoc = u8;
# }
#
#[derive(Debug, PartialEq)]
enum Foo<A, B, C: Trait + ?Sized> {
    A(A),
    B { b: PhantomData<B> },
    C(C::Assoc),
}
#
# #[derive(Debug)]
# struct NoEq;

assert_eq!(Foo::<_, NoEq, NoEq>::A(3), Foo::A(3));
assert_ne!(Foo::<_, NoEq, NoEq>::A(3), Foo::A(0));

assert_eq!(Foo::<u16, NoEq, NoEq>::B { b: PhantomData }, Foo::B { b: PhantomData });

assert_eq!(Foo::<i32, NoEq, NoEq>::C(3), Foo::C(3));
assert_ne!(Foo::<i32, NoEq, NoEq>::C(3), Foo::C(0));
```
This generates code equivalent to:
```rust
# use std::marker::PhantomData;
#
# trait Trait {
#     type Assoc;
# }
# impl<T: ?Sized> Trait for T {
#     type Assoc = u8;
# }
#
# enum Foo<A, B, C: Trait + ?Sized> {
#     A(A),
#     B { b: PhantomData<B> },
#     C(C::Assoc),
# }
#
impl<A, B, C: Trait + ?Sized> PartialEq for Foo<A, B, C>
where
    A: PartialEq,
    PhantomData<B>: PartialEq, // `B: PartialEq` is generated by `std` instead
    C::Assoc: PartialEq,       // `C: PartialEq` is generated by `std` instead
{
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        std::mem::discriminant(self) == std::mem::discriminant(other) &&
            match (self, other) {
                (Self::A(self_0), Self::A(other_0)) => { self_0 == other_0 }
                (Self::B { b: self_0 }, Self::B { b: other_0 }) => { self_0 == other_0 }
                (Self::C(self_0), Self::C(other_0)) => { self_0 == other_0 }
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
    }

    #[inline]
    fn ne(&self, other: &Self) -> bool {
        std::mem::discriminant(self) != std::mem::discriminant(other) ||
            match (self, other) {
                (Self::A(self_0), Self::A(other_0)) => { self_0 != other_0 }
                (Self::B { b: self_0 }, Self::B { b: other_0 }) => { self_0 != other_0 }
                (Self::C(self_0), Self::C(other_0)) => { self_0 != other_0 }
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
    }
}
```
